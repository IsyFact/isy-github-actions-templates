name: Trigger Documentation Build Template

on:
  workflow_call:
    inputs:
      log_level:
        description: 'Log severity level for the Antora build (debug, info, warn, error)'
        required: false
        type: string
        default: 'info'
      failure_level:
        description: 'Log failure level for the Antora build (fatal, error, warn, none)'
        required: false
        type: string
        default: 'fatal'
    secrets:
      ANTORA_TRIGGER_TOKEN:
        description: 'GitHub token to trigger the documentation build'
        required: true

jobs:
  TriggerDocsBuild:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        if: ${{ github.event_name == 'pull_request' }}
        with:
          fetch-depth: 0

      - name: Check if PR documentation build is necessary
        id: adoc-changes
        if: ${{ github.event_name == 'pull_request' }}
        continue-on-error: true
        run: |
          git fetch origin ${{ github.base_ref }}
          if git diff --name-only origin/${{ github.base_ref }}...HEAD) | grep -q ".adoc"; then
            echo "pr_build=true" >> $GITHUB_OUTPUT
          else
            echo "pr_build=false" >> $GITHUB_OUTPUT
          fi

      - name: Trigger documentation build
        uses: codex-/return-dispatch@v2.1.0
        id: trigger_build
        if: github.event_name == 'push' || steps.adoc-changes.outputs.pr_build == 'true'
        with:
          token: ${{ secrets.ANTORA_TRIGGER_TOKEN }}
          ref: main
          repo: isyfact.github.io
          owner: IsyFact
          workflow: antora_build.yml
          workflow_inputs: |
            {
              "log_level": "${{ inputs.log_level }}",
              "failure_level": "${{ inputs.failure_level }}",
              "pr_repo": "${{ github.repository }}",
              "pr_branch": "${{ github.ref }}",
              "pr_target": "${{ github.base_ref }}"
            }

      - name: Wait for documentation build completion (Run ID - ${{ steps.trigger_build.outputs.run_id }})
        uses: codex-/await-remote-run@v1.13.0
        id: wait_for_completion
        if: github.event_name == 'push' || steps.adoc-changes.outputs.pr_build == 'true'
        continue-on-error: true
        with:
          token: ${{ secrets.ANTORA_TRIGGER_TOKEN }}
          repo: isyfact.github.io
          owner: IsyFact
          run_id: ${{ steps.trigger_build.outputs.run_id }}
          run_timeout_seconds: 900 # 15 minutes (optional)
          poll_interval_ms: 15000 # 15 seconds (optional)

      - name: Fetch Antora log
        if: steps.adoc-changes.outputs.pr_build == 'true'
        env:
          GH_TOKEN: ${{ secrets.ANTORA_TRIGGER_TOKEN }}
          RUN_ID: ${{ steps.trigger_build.outputs.run_id }}
        run: |
          # Fetch the logs for the given run ID using GitHub CLI
          echo "Fetching Antora log for run ID: $RUN_ID from repository IsyFact/isyfact.github.io..."
          gh run download ${{ env.RUN_ID }} -n "antora-log" --repo "IsyFact/isyfact.github.io"

      - name: Generate PR comment
        id: generate-pr-comment
        if: steps.adoc-changes.outputs.pr_build == 'true'
        run: |
          echo "Processing Antora log..."
          
          input_file="antora_output.log"
          output_file="formatted_logs.md"
          
          echo "## Build Documentation Logs üìú" > "$output_file"
                    
          # Keep track of the current source and branch
          current_source=""
          current_branch=""
          # Keep track of the block state
          in_block=false
          # Keep track of the build success, according to the failure_level (workflow input) 
          build_successful=true
                    
          while IFS= read -r line; do
          
            level=$(echo "$line" | jq -r '.level')
          
            if [[ "$level" = "fatal" ]]; then
              line_text=$(echo "$line" | jq -r '"\(.level | ascii_upcase) \(.msg)"')
              echo "<strong>‚ùå $line_text</strong>" >> "$output_file"
              # fatal errors fail the build in each case
              build_successful=false
              continue
            fi
          
            # Extract the source and branch information
            source=$(echo "$line" | jq -r '.source.url // empty' | awk -F'/' '{print $NF}')
            branch=$(echo "$line" | jq -r '.source.refname // empty')
          
            # Use the last part of the worktree if the ref points to HEAD (i.e. in case of a tag)
            if [[ "$branch" = "HEAD" ]]; then
              worktree=$(echo "$line" | jq -r '.source.worktree')
              branch="${worktree##*/}"
            fi
          
            # If the source or branch is missing, skip this line
            if [[ -z "$source" || -z "$branch" ]]; then
              echo "::notice title=Skipping line: $line"
              continue
            fi
          
            # Check if the source or branch has changed
            if [[ "$source" != "$current_source" || "$branch" != "$current_branch" ]]; then
              # Update the current source and branch
              current_source="$source"
              current_branch="$branch"
          
              # Close previous details block if it's not the first one
              if [[ "$in_block" = true ]]; then
                echo "</details>" >> "$output_file"
              fi
              # Start a new details block for a new source
              echo "<details>" >> "$output_file"
              echo "<summary><strong>üìÅ Content Source: $current_source (branch: $current_branch)</strong></summary>" >> "$output_file"
              echo "" >> "$output_file"  # Add a new line for formatting
              in_block=true
            fi
          
            # Write first line (level and message)
            first_line=$(echo "$line" | jq -r '"- \(.level): \(.msg)"')
          
            case "$level" in
              error*)
                echo "${first_line//error:/üî¥ **ERROR**}" >> "$output_file"
                if [[ "${{ inputs.failure_level }}" = "error" || "${{ inputs.failure_level }}" = "warn" ]]; then
                  build_successful=false
                fi
                ;;
              warn*)
                echo "${first_line//warn:/üü° **WARN**}" >> "$output_file"
                if [[ "${{ inputs.failure_level }}" = "warn" ]]; then
                  build_successful=false
                fi
                ;;
              info)
                echo "${first_line//info:/üü¢ **INFO**}" >> "$output_file"
                ;;
              debug*)
                echo "${first_line//debug:/üîµ **DEBUG**}" >> "$output_file"
                ;;
            esac
          
            # Write second line (file and line)
            second_line=$(echo "$line" | jq -r '"    - File: `\(.file.path? // "N/A" | sub("^/home/runner/work/isyfact.github.io/isyfact.github.io/"; ""))`:\(.file.line // "N/A")\n"')
            echo "$second_line" >> "$output_file"
          
          done < "$input_file"

          # Ensure the last details block is closed
          if [[ "$in_block" = true ]]; then
            echo "</details>" >> "$output_file"
          fi
          if [[ "$build_successful" = true ]]; then
            echo "<strong>‚úÖ Documentation build successful!</strong>" >> "$output_file"
          else
            echo "<strong>‚ùå Documentation build failed!</strong>" >> "$output_file"
          fi
  
          cat formatted_logs.md
          
          echo "success=$build_successful" >> $GITHUB_OUTPUT
          
      - name: Comment on PR
        if: steps.adoc-changes.outputs.pr_build == 'true'
        uses: thollander/actions-comment-pull-request@v3.0.1
        with:
          file-path: formatted_logs.md
          comment-tag: antora-logs

#      - name: Fail check if documentation build failed
#        if: ${{ steps.generate-pr-comment.outputs.success == 'false' }}
#        run: exit 1
